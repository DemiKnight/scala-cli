"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3831],{9705:function(e,t,a){a.d(t,{m:function(){return o},v:function(){return i}});var n=a(7294),l=a(2004);function i(e){var t=e.children;return n.createElement("div",{className:"runnable-command"},t)}function o(e){var t=e.url;return n.createElement(l.Z,{playing:!0,loop:!0,muted:!0,controls:!0,width:"100%",height:"",url:t})}},4429:function(e,t,a){a.r(t),a.d(t,{assets:function(){return u},contentTitle:function(){return c},default:function(){return m},frontMatter:function(){return r},metadata:function(){return p},toc:function(){return d}});var n=a(3117),l=a(102),i=(a(7294),a(3905)),o=a(9705),s=["components"],r={title:"Scala Toolkit",sidebar_position:7},c="Scala Toolkit",p={unversionedId:"guides/toolkit",id:"guides/toolkit",title:"Scala Toolkit",description:"Scala Toolkit is an ongoing",source:"@site/docs/guides/toolkit.md",sourceDirName:"guides",slug:"/guides/toolkit",permalink:"/docs/guides/toolkit",draft:!1,editUrl:"https://github.com/Virtuslab/scala-cli/edit/main/website/docs/guides/toolkit.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{title:"Scala Toolkit",sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"IDE support",permalink:"/docs/guides/ide"},next:{title:"Migrating from the old Scala runner",permalink:"/docs/guides/old-runner-migration"}},u={},d=[{value:"Scala Toolkit and tests",id:"scala-toolkit-and-tests",level:2},{value:"Other toolkits",id:"other-toolkits",level:2}],k={toc:d};function m(e){var t=e.components,a=(0,l.Z)(e,s);return(0,i.kt)("wrapper",(0,n.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"scala-toolkit"},"Scala Toolkit"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/scala/toolkit"},"Scala Toolkit")," is an ongoing\neffort by Scala Center and VirtusLab to compose a set of approachable libraries to solve\neveryday problems."),(0,i.kt)("p",null,"You can easily add it to your Scala CLI project with the ",(0,i.kt)("inlineCode",{parentName:"p"},"--toolkit")," option:"),(0,i.kt)(o.v,{mdxType:"ChainedSnippets"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"title=UseOsLib.sc",title:"UseOsLib.sc"},"println(os.pwd)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"scala-cli UseOsLib.sc --toolkit latest\n"))),(0,i.kt)("p",null,"Similarly, you can achieve the same with the ",(0,i.kt)("inlineCode",{parentName:"p"},"using toolkit")," directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"compile",compile:!0},"//> using toolkit latest\n@main def printPwd: Unit = println(os.pwd)\n")),(0,i.kt)("h2",{id:"scala-toolkit-and-tests"},"Scala Toolkit and tests"),(0,i.kt)("p",null,"Adding Scala Toolkit to your project effectively adds 2 dependencies to your classpath:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"org.scala-lang:toolkit:<version>")," for your main scope (usable everywhere in the project);"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"org.scala-lang:toolkit-test:<version>")," for your test scope (usable only in tests).")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"toolkit-test")," includes a batch of libraries only relevant for testing (like i.e. ",(0,i.kt)("inlineCode",{parentName:"p"},"munit"),"), which you probably don't\nwant on your main scope\nclass path (which is why Scala CLI won't put it there).\nAnd so, you can use it like this:"),(0,i.kt)(o.v,{mdxType:"ChainedSnippets"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"title=Something.test.scala",title:"Something.test.scala"},'//> using toolkit latest\nclass Something extends munit.FunSuite {\n  test("foo") {\n    assert(true)\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"scala-cli test Something.test.scala\n"))),(0,i.kt)("p",null,"Also, in case you only want Scala Toolkit to be added to the test scope (and not for the main scope in any capacity),\nyou can always use the ",(0,i.kt)("inlineCode",{parentName:"p"},"using test.toolkit")," directive."),(0,i.kt)(o.v,{mdxType:"ChainedSnippets"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"title=project.scala",title:"project.scala"},"//> using test.toolkit latest\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"title=Another.test.scala",title:"Another.test.scala"},'class Another extends munit.FunSuite {\n  test("foo") {\n    assert(os.pwd.last.nonEmpty)\n  }\n}\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"scala-cli test Another.test.scala project.scala\n"))),(0,i.kt)("p",null,"More details about test scope directives can be found in\nthe ",(0,i.kt)("a",{parentName:"p",href:"./using-directives#directives-with-a-test-scope-equivalent"},(0,i.kt)("inlineCode",{parentName:"a"},"using")," directives guide"),"."),(0,i.kt)("h2",{id:"other-toolkits"},"Other toolkits"),(0,i.kt)("p",null,"Scala CLI also supports adding other toolkits to your project in a similar manner. Those have to follow the same\nstructure of 2 dependencies with the names ",(0,i.kt)("inlineCode",{parentName:"p"},"toolkit")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"toolkit-test"),".\nTo do so, you have to explicitly pass the organisation the toolkit was released under (or an alias if defined)."),(0,i.kt)("p",null,"For example, to add the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/typelevel/toolkit"},"Typelevel Toolkit")," to your project, you can pass it with\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"--toolkit")," option:"),(0,i.kt)(o.v,{mdxType:"ChainedSnippets"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"title=UseTypelevel.scala",title:"UseTypelevel.scala"},"import cats.effect.*\nimport fs2.io.file.Files\n\nobject Hello extends IOApp.Simple {\n  def run = Files[IO].currentWorkingDirectory.flatMap { cwd =>\n    IO.println(cwd.toString)\n  }\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"scala-cli UseTypelevel.scala --toolkit org.typelevel:latest\nscala-cli UseTypelevel.scala --toolkit typelevel:latest # typelevel has a shorter alias defined\n"))),(0,i.kt)("p",null,"Similarly, you can achieve the same with the ",(0,i.kt)("inlineCode",{parentName:"p"},"using toolkit")," directive:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"compile",compile:!0},"//> using toolkit org.typelevel:latest\n\nimport cats.effect.*\nimport fs2.io.file.Files\n\nobject Hello extends IOApp.Simple {\n  def run = Files[IO].currentWorkingDirectory.flatMap { cwd =>\n    IO.println(cwd.toString)\n  }\n}\n")),(0,i.kt)("p",null,"Or with the alias:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-scala",metastring:"compile",compile:!0},"//> using toolkit typelevel:latest\n\nimport cats.effect.*\nimport fs2.io.file.Files\n\nobject Hello extends IOApp.Simple {\n  def run = Files[IO].currentWorkingDirectory.flatMap { cwd =>\n    IO.println(cwd.toString)\n  }\n}\n")))}m.isMDXComponent=!0}}]);